# BBF算法实现与对比分析报告

本实验的全部代码开源在 <https://github.com/Nictheboy/college-alg-2-bbf>。

## 1. 背景与目的

本项目旨在实现并评估Best Bin First (BBF) 近似最近邻搜索算法的性能。我们将其与传统的暴力搜索和标准K-D树精确搜索在构建时间、查询速度、准确性及空间开销方面进行了比较。BBF通过限制搜索节点数（本实验中 `t=200`）来加速查询。

## 2. 算法简介

* **暴力搜索 (BruteForce)**：逐个计算查询点与所有数据点的距离，保证找到精确最近邻。
* **标准K-D树 (KDTree_Exact)**：构建K维空间划分树，通过剪枝策略高效查找精确最近邻。
* **BBF搜索 (KDTree_Approx_BBF200)**：基于K-D树，但在搜索时限制最多检查200个节点，以牺牲部分精度换取速度。

## 3. 实验设置

* **数据集**: 100个独立数据集，每个包含约10万个8维建树点和100个查询点。
* **评价指标**:
  * 构建时间 (ms)
  * 平均查询时间 (ms)
  * 准确率 (%): `d_approx / d_exact <= 1.05` 的查询比例。
  * 平均距离比值: `d_approx / d_exact` 的平均值。
  * 空间开销 (MB)

## 4. 实验结果

下表汇总了各算法在100个数据集上的平均性能表现（均值 ± 标准差）：

| 算法                 | 构建时间 (ms)       | 查询时间 (ms)      | 准确率 (%)          | 平均距离比值       | 空间开销 (MB)  |
| :------------------- | :------------------ | :----------------- | :------------------ | :----------------- | :------------- |
| BruteForce           | 14.7983 ± 0.5339    | 263.7338 ± 5.9178  | 100.0000 ± 0.0000   | 1.0000 ± 0.0000    | 3.43 ± 0.00    |
| KDTree_Exact         | 149.7471 ± 4.3020   | 6.6040 ± 0.5330    | 100.0000 ± 0.0000   | 1.0000 ± 0.0000    | 5.34 ± 0.00    |
| KDTree_Approx_BBF200 | 150.4464 ± 10.9730  | 0.9620 ± 0.0285    | 64.6900 ± 4.8594    | 1.0989 ± 0.0162    | 5.34 ± 0.00    |

## 5. 结果分析

* **查询速度**: BBF算法 (`KDTree_Approx_BBF200`) 查询最快，平均0.96ms。比标准K-D树的6.6ms和暴力搜索的263.7ms快很多。近似搜索策略的功劳。
* **准确性**: BBF追求速度，准确性有所牺牲。准确率（1.05阈值）约64.69%。平均距离比值1.0989，说明找到的点平均比真邻居远大概9.89%。暴力和标准K-D树都100%准。
* **构建时间**: K-D树（精确和BBF）构建时间差不多（约150ms）。比暴力搜索（约15ms）慢，因为要建索引树。
* **空间开销**: K-D树系列（5.34MB）比暴力搜索（3.43MB）占空间多点，存树结构。BBF的`t`参数不影响建树空间。

## 6. 结论

实验显示，BBF算法（`t=200`）查得飞快，但结果不太准。标准K-D树在速度和准确上平衡得还行。暴力搜索准是准，就是慢。BBF适合那种要快、能接受点误差的场景。

## 7. 理论探讨简述

BBF复杂度跟参数`t`有关。`t`限制了搜索深度，所以它能比标准K-D树快。但`t`太小，好结果可能就找不到了，准确率自然就下去了。高维数据对K-D树这类结构不太友好，它们划分空间的效果会变差，BBF也会受影响。

## 声明

本实验报告的撰写及相关代码的实现，部分工作是在大型语言模型 Gemini (模型版本：Gemini 2.5 Pro Preview 05-06) 的辅助下完成的。模型主要在代码实现、调试、结果分析和报告撰写方面提供了帮助和建议。
